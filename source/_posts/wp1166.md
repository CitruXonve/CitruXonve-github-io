---
title: 2015 Multi-University Training Contest 4
author: Semprathlon / Simfae Dean
tags:
	- Multi-Uni
categories:
	- ACM-ICPC
	- Programing
date: 2015-07-31 16:38:55
---
[1009 Walk Out](http://acm.hdu.edu.cn/showproblem.php?pid=5335)
====
状态压缩方面，虽然想到了用一维的x+y替代二维的x,y，但并没有做到位。   
既然可以转化成二维DP，还有何搜索必要   
寻找合适的出发点时，不要陷入“极近点”而丢失了“最近点”！   
[code lang="cpp"]
#include&lt;cctype&gt;

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
const int inf=0x7fffffff;
const double eps=1e-3;

typedef pair&lt;int,int&gt; pr;
const int dir[4][2]={ {0,-1},{0,1},{-1,0},{1,0}};
const int maxn=1010;
const int maxm=1010;
int n,m,X0,Y0;
bool g[maxn][maxm],f[maxn][maxm],vis[maxn][maxm];
char str[maxn];

bool can(int x,int y){
    if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) return 0;
    return 1;
}
bool can(pr p){
    return can(p.first,p.second);
}
int mdis(int x,int y){
    return abs(x-n)+abs(y-m);
}
int mdis(pr p){
    return mdis(p.first,p.second);
}
int geth(pr p){
    return p.first+p.second;
}

void find0(int x,int y){
        if (vis[x][y]||!can(x,y)) return;
        vis[x][y]=1;
        if (g[x][y]) return;
        f[x][y]=1;
        if (x+y&gt;X0+Y0)
        {
            X0=x;Y0=y;
        }
        for(int i=0;i&lt;4;i++) find0(x+dir[i][0],y+dir[i][1]);
}


int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {

        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%s&quot;,str+1);
            for(int j=1;j&lt;=m;j++)
            {
                if (str[j]=='1') g[i][j]=1;
                else g[i][j]=0;
            }
        }

        X0=0;Y0=0;
        memset(vis[0],0,maxn*maxm*sizeof(vis[0][0]));
        memset(f[0],0,maxn*maxm*sizeof(f[0][0]));
        find0(1,1);
        //cout&lt;&lt;X0&lt;&lt;' '&lt;&lt;Y0&lt;&lt;endl;
        if (X0+Y0==n+m){
            printf(&quot;%d\n&quot;,0);
            continue;
        }
        if (X0+Y0&lt;2)
        {
            X0=1;Y0=1;
            f[1][1]=1;
            printf(&quot;1&quot;);
        }
        for(int i=X0+Y0;i&lt;n+m;i++)
        {
            int k=1;
            for(int j=max(1,i-m);j&lt;=min(n,i-1);j++)
                if (f[j][i-j])
            {
                int k1=j&lt;n?g[j+1][i-j]:1;
                int k2=i-j&lt;m?g[j][i-j+1]:1;
                k=min(k,min(k1,k2));
            }
            for(int j=max(1,i-m);j&lt;=min(n,i-1);j++)
                if (f[j][i-j])
            {
                int k1=j&lt;n?g[j+1][i-j]:1;
                int k2=i-j&lt;m?g[j][i-j+1]:1;
                if (k1==k) f[j+1][i-j]=1;
                if (k2==k) f[j][i-j+1]=1;
            }
            printf(&quot;%d&quot;,k);
        }
        puts(&quot;&quot;);
    }
    return 0;
}
[/code]